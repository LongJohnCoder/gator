// The goal of this program is to draw two objects
// Each uses the same shader pair and meshes, but different model matrices and colors

// Some kinda metaprogramming 
with type T:
declare type varying;

mat4 model;
mat4 view;
mat4 projection;

// All functions must have a target language; this one is typescript
typescript void main() {
    // compiling a program recovers its member variables statically
    // the set of writeable member variables of a program are as follows (U = union):
    // { in(VERTEX) } U { uniform(VERTEX) } U { uniform(FRAGMENT) }
    // the set of readable member variables of a program are the out variable of FRAGMENT
    // We can't yet write or read these these variables
    program = compile(vertex, fragment);
    ...
    model1 = mat4.create();
    mat4.translate(model1, model1, [10., 10., 10.]);
    model2 = mat4.create();
    mat4.translate(model2, model2, [-10., -10., -10.]);
    while (true) {
        render(get_mesh());
    }
}

typescript void render(mesh) {
    // pseudo-code
    update(view);
    update(projection);

    // Binds the current program (restricted to a value)
    $current = program;

    // $current's variables should be determined statically
    // To bind a new variable, we create a partial function with some arguments applied
    // Note that binding a variable in this way is equivalent to GLSL's bind function
    // Also note that calling partial on a non-bound program gives an error
    with_mesh = partial(program, vPosition = mesh.positions);

    // Calling with_mesh runs the underlying bound program (which here returns void)
    // Gives a static error if the called program is not bound to $current
    // Call with any number of arguments; equivalent to binding then calling
    with_mesh(color = [1., 1., 0.]);

    // At this point, $current's member variables become readable, though this is useless for now
    // Note, however, that the program's member variables are _still_ writeable
    $uModel = model2; // This actually updates uModel for $current!  Thus we need to include a $

    // Note that $current.vPosition has been bound earlier, so that still holds
    $current(color = [1., 0., 1.]);
}

// The glsl keyword targets the compilation of this program to glsl
// The program keyword indicates that this is something that must be bound to be run
glsl program void vertex (vec3 vPosition, vec3 color) {
    out vec3 vPosition; // associated fragment must have 'in' associated with each out;
    
    void main() {
      vPosition = aPosition;
      gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.);
    }
}

glsl program void fragment(vec3 vPosition, vec3 color) {
    out vec4 gl_FragColor;

    void main() {
        gl_FragColor = uView * uModel * vec4(vPosition, 1.);
    }

}