// GLSL Type Declarations
declare type vec3 is float[3];
declare type vec4 is float[4];
declare type mat3 is float[3][3];
declare type mat4 is float[4][4];

// Local Type Declarations
type scalar is float;
type angle is scalar;
type color is vec3;
type alphaColor is vec4;

// GLSL Function Types
declare T +<T:vec3>(T v1, T v2);
declare T -<T:vec3>(T v1, T v2);
declare T -<T:vec3>(T v);
declare T *<T:vec3,U:float>(T v, U f);
declare T *<T:vec3,U:float>(U f, T v);
declare T /<T:vec3,U:float>(T f1, U f2);

declare T +<T:vec4>(T v1, T v2);
declare T -<T:vec4>(T v1, T v2);
declare T -<T:vec4>(T v);
declare T *<T:vec4,U:float>(T v, U f);
declare T *<T:vec4,U:float>(U f, T v);

declare T +<T:float>(T f1, T f2);
declare T -<T:float>(T f1, T f2);
declare T -<T:float>(T f);
declare T *<T:float>(T f1, T f2);
declare T /<T:float>(T f1, T f2);

declare vec3 *<T:mat3,U:vec3>(T m, U v);
declare mat3 +<T:mat3,U:mat3>(T m, U v);
declare mat3 *<T:mat3,U:mat3>(T m, U v);

declare vec4 *<T:mat4,U:vec4>(T m, U v);
declare T +<T:mat4>(T m1, T m2);
declare mat4 *<T:mat4,U:mat4>(T m, U v);

declare float cos(float f);
declare float sqrt(float f);
declare float acos(float f);

declare vec4 vec4<T:float[3],U:float>(T v, U f);
declare vec3 vec3<T:float[4]>(T v);

declare float dot<T: vec3>(T v1, T v2);
// declare T normalize<T : vec3>(T x);
declare vec3 normalize(vec3 x);
declare T max<T: float>(T f1, T f2);
declare T reflect<T : vec3>(T v1, T v2);
declare T pow<T:float>(T f1, T f2);

// Geometric Objects and Operations

prototype geometry {
    object point<r>;
    object vector<r>;
    object direction<r>;
    object transformation<r1, r2>;

    vector<r> +(vector<r> x, vector<r> y);
    vector<r> -(vector<r> x, vector<r> y);
    vector<r> -(vector<r> x);
    direction<r> -(direction<r> x);
    vector<r> *(vector<r> v, scalar s);
    vector<r> *(scalar s, vector<r> v);
    point<r> +(point<r> p, vector<r> v);
    point<r> +(vector<r> p, point<r> v);
    vector<r> -(point<r> x, point<r> y);
    vector<r> -(point<r> x);
    vector<r2> *(transformation<r1, r2> m, vector<r1> v);
    vector<r2> *(transformation<r1, r2> m, direction<r1> v);
    point<r2> *(transformation<r1, r2> m, point<r1> v);
    transformation<r1, r2> +(transformation<r1, r2> m1, transformation<r1, r2> m2);
    transformation<r1, r3> *(transformation<r1, r2> m1, transformation<r2, r3> m2);

    angle dot(direction<r> v1, direction<r> v2);
    direction<r> normalize(vector<r> v);
    direction<r> normalize(direction<r> v);
    vector<r> reflect(direction<r> v1, direction<r> v2);
}

// Coordinate Scheme Definitions

coordinate cart3 : geometry {
    dimension 3;

    object point<r> is float[3];
    object vector<r> is float[3];
    object direction<r> is float[3];
    object transformation<r1, r2> is float[3][3];

    vector<r> +(vector<r> x, vector<r> y) {
        return (x as! vec3 + y as! vec3) as! vector<r>;
    }
    vector<r> -(vector<r> x, vector<r> y) {
        return (x as! vec3 - y as! vec3) as! vector<r>;
    }
    vector<r> *(vector<r> v, scalar s) {
        return (v as! vec3 * s) as! vector<r>;
    }
    vector<r> *(scalar s, vector<r> v) {
        return (s * v as! vec3) as! vector<r>;
    }
    vector<r> -(vector<r> v) {
        return (-v as! vec3) as! vector<r>;
    }
    direction<r> -(direction<r> v) {
        return (-v as! vec3) as! direction<r>;
    }
    point<r> +(point<r> p, vector<r> v) {
        return (p as! vec3 + v as! vec3) as! point<r>;
    }
    point<r> +(vector<r> v, point<r> p) {
        return (p as! vec3 + v as! vec3) as! point<r>;
    }
    vector<r> -(point<r> x, point<r> y) {
        return (x as! vec3 - y as! vec3) as! vector<r>;
    }
    vector<r> -(point<r> v) {
        return (-v as! vec3) as! vector<r>;
    }
    vector<r2> *(transformation<r1, r2> m, vector<r1> v) {
        return (m as! mat3 * v as! vec3) as! vector<r2>;
    }
    vector<r2> *(transformation<r1, r2> m, direction<r1> d) {
        return (m as! mat3 * d as! vec3) as! vector<r2>;
    }
    point<r2> *(transformation<r1, r2> m, point<r1> p) {
        return (m as! mat3 * p as! vec3) as! point<r2>;
    }
    transformation<r1, r2> +(transformation<r1, r2> m1, transformation<r1, r2> m2) {
        return (m1 as! mat3 + m2 as! mat3) as! transformation<r1, r2>;
    }
    transformation<r1, r3> *(transformation<r1, r2> m1, transformation<r2, r3> m2) {
        return (m1 as! mat3 * m2 as! mat3) as! transformation<r1, r3>;
    }

    angle dot(direction<r> v1, direction<r> v2) {
        return (dot(v1 as! vec3, v2 as! vec3) as! angle);
    }
    direction<r> normalize(vector<r> v) {
        return (normalize(v as! vec3) as! direction<r>);
    }
    direction<r> normalize(direction<r> v) {
        return v;
    }
    vector<r> reflect(direction<r> v1, direction<r> v2) {
        return (reflect(v1 as! vec3, v2 as! vec3) as! vector<r>);
    }
}

coordinate hom : geometry {
    dimension 3;

    object point<r> is float[4];
    object vector<r> is float[4];
    object direction<r> is float[4];
    object transformation<r1, r2> is float[4][4];

    point<r> +(point<r> p, vector<r> v) {
        return (p as! vec4 + v as! vec4 * p[3]) as! point<r>;
    }
    point<r> +(vector<r> v, point<r> p) {
        return (p as! vec4 + v as! vec4 * p[3]) as! point<r>;
    }
    vector<r> -(point<r> x, point<r> y) {
        return (x as! vec4 * y[3] - y as! vec4 * x[3]) as! vector<r>;
    }
    vector<r2> *(transformation<r1, r2> m, vector<r1> v) {
        return (m as! mat4 * v as! vec4) as! vector<r2>;
    }
    vector<r2> *(transformation<r1, r2> m, direction<r1> d) {
        return (m as! mat4 * d as! vec4) as! vector<r2>;
    }
    point<r2> *(transformation<r1, r2> m, point<r1> p) {
        return (m as! mat4 * p as! vec4) as! point<r2>;
    }
    transformation<r1, r2> +(transformation<r1, r2> m1, transformation<r1, r2> m2) {
        return (m1 as! mat4 + m2 as! mat4) as! transformation<r1, r2>;
    }
    transformation<r1, r3> *(transformation<r1, r2> m1, transformation<r2, r3> m2) {
        return (m1 as! mat4 * m2 as! mat4) as! transformation<r1, r3>;
    }
}

// Reference Frame Declarations

frame model has dimension 3;
frame world has dimension 3;
frame camera has dimension 3;

// Transformation Functions

with frame(3) r:
hom.point<r> homify(cart3.point<r> v) {
    return vec4(v, 1.) as! hom.point<r>;
}
with frame(3) r:
hom.vector<r> homify(cart3.vector<r> v) {
    return vec4(v, 0.) as! hom.vector<r>;
}
with frame(3) r:
cart3.point<r> hom_reduce(hom.point<r> v) {
    return (vec3(v) / v[3]) as! cart3.point<r>;
}
with frame(3) r:
cart3.vector<r> hom_reduce(hom.vector<r> v) {
    return vec3(v) as! cart3.vector<r>;
}
alphaColor alpha<T:color>(T v) {
    return vec4(v, 1.) as! alphaColor;
}

// Global Variables

varying cart3.point<model> vPosition;
uniform hom.transformation<model, world> uModel;
uniform hom.transformation<world, camera> uView;
varying cart3.vector<model> vNormal;
uniform cart3.point<world> uLight;

void main() {
    color ambient = [.1, 0., 0.];
    color diffColor = [0.2, 0.8, 0.4];
    color specColor = [1.0, 1.0, 1.0];

    auto worldPos = hom_reduce(uModel*homify(vPosition));
    auto camPos = hom_reduce(uView*homify(worldPos));
    auto worldNorm = normalize(hom_reduce(uModel*homify(vNormal)));

    auto lightDir = normalize(uLight - worldPos);
    auto lightWorldDot = dot(lightDir, worldNorm);
    scalar diffuse = max(lightWorldDot, 0.);

    auto reflectDir = normalize(hom_reduce(uView * homify(reflect(-lightDir, worldNorm))));

    scalar specular = pow(max(dot(normalize(-camPos), reflectDir), 0.), 32.);

    vec4 gl_FragColor = vec4(ambient + diffuse * diffColor + specular * specColor, 1.0);
}