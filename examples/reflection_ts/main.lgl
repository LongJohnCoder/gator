//Declare Types
declare type WebGLRenderingContext;
declare type WebGLProgram;
declare type WebGLUniformLocation;
declare type WebGLTexture;
declare type mat3;
declare type mat4;
declare type vec3;
declare type vec4;
declare type lgl.Mesh;
declare type WebGLBuffer;
declare type WebGLFramebuffer;
declare type HTMLCanvasElement;
declare type HTMLImageElement;
declare type WebGLRenderbuffer;

//Dirty hacks
declare void null;
declare HTMLImageElement[6] img;
declare type any; // = WebGLTexture | null

//Declare Functions
//misc
declare string require(string someModule);
//mat3
declare mat3 mat3.create();
declare mat3 mat3.normalFromMat4(mat3 f1, mat4 f2);
declare mat3 mat3.fromMat4(mat3 f1, mat4 f2);
declare mat3 mat3.invert(mat3 f1, mat3 f2);
//mat4
declare mat4 mat4.create();
with mat4 T: declare T mat4.rotateY(T model1, T model2, float someFloat);
with mat4 T: declare T mat4.multiply(T f1, T f2, T f3);
declare mat4 mat4.perspective(mat4 f1, float f2, float f3, float f4, float f5);
declare mat4 mat4.identity(mat4 f1);
declare mat4 mat4.scale(mat4 f1, mat4 f2, float[3] f3);
declare mat4 mat4.rotateX(mat4 f1, mat4 f2, float f3);

//vec3
declare vec3 vec3.fromValues(float x, float y, float z);
//vec4
declare vec4 vec4.fromValues(float f1, float f2, float f3, float f4);
declare vec4 vec4.create();
declare vec4 vec4.transformMat4(vec4 f1, vec4 f2, mat4 f3);
//gl
with WebGLProgram T: declare void gl.useProgram(T someProgram);
declare void gl.uniform3fv(WebGLUniformLocation loc1, vec3 someVec3);
declare void gl.uniform4fv(WebGLUniformLocation f1, vec4 f2);
declare void gl.uniformMatrix4fv(WebGLUniformLocation someLoc, bool someBool, mat4 someMat4);
declare void gl.disableVertexAttribArray(float f1);
declare void gl.disable(int someInt);
declare void gl.enable(int someInt);
declare void gl.clearColor(int f1, int f2, int f3, int f4);
declare void gl.clear(int b);
declare void gl.bindTexture(float f1, any f2);
// declare void gl.bindFramebuffer(float f1, WebGLFramebuffer f2);
declare void gl.bindFramebuffer(float f1, void f2);
declare void gl.bindFramebuffer(float f1, any f2);
declare bool gl.COLOR_BUFFER_BIT;
declare bool gl.DEPTH_BUFFER_BIT;
declare float gl.TEXTURE_CUBE_MAP;
declare float gl.FRAMEBUFFER;
declare float gl.COLOR_ATTACHMENT0;
declare float gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
declare float gl.TEXTURE_CUBE_MAP_POSITIVE_X;
declare float gl.TEXTURE_CUBE_MAP_POSITIVE_Z;
declare float gl.TEXTURE_CUBE_MAP_NEGATIVE_X;
declare float gl.TEXTURE_CUBE_MAP_POSITIVE_Y;
declare float gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;
declare float gl.RGBA; 
declare float gl.DEPTH_COMPONENT16; 
declare float gl.DEPTH_ATTACHMENT; 
declare int gl.UNSIGNED_BYTE;
declare float gl.RENDERBUFFER;
declare void gl.viewport(float f1, float f2, float f3, float f4);
declare void gl.framebufferTexture2D(float f1, float f2, float f3, any f4, float f5);
declare void gl.generateMipmap(float f1);
declare void gl.uniformMatrix3fv(WebGLUniformLocation f1, bool f2, mat3 f3);
declare void gl.texImage2D(float f1, float f2, float f3, float f4, float f5, float f6, float f7, int f8, void f9);
declare any gl.createTexture();
declare any gl.createFramebuffer();
declare any gl.createRenderbuffer();
declare void gl.bindRenderbuffer(float f1, any f2);
declare void gl.renderbufferStorage(float f1, float f2, float f3, float f4);
declare void gl.framebufferRenderbuffer(float f1, float f2, float f3, any f4);
//lgl
declare WebGLProgram lgl.compileProgram(WebGLRenderingContext gl, string vertex, string fragment);
declare WebGLUniformLocation lgl.uniformLoc(WebGLRenderingContext gl, WebGLProgram prog, string someName);
declare float lgl.attribLoc(WebGLRenderingContext gl, WebGLProgram program, string someName);
declare lgl.Mesh lgl.getBunny(WebGLRenderingContext gl);
declare void lgl.drawMesh(WebGLRenderingContext gl, lgl.Mesh someMesh);
declare void lgl.bind_attrib_buffer(WebGLRenderingContext gl, float someFloat, WebGLBuffer someBuffer, int someSize);
declare lgl.Mesh lgl.getCube(WebGLRenderingContext gl, float f1, float f2, float f3, float f4, float f5);
//html


//Imports
#"import * as lgl from '../lglexample';";

//Globals
const WebGLRenderingContext gl;
const WebGLProgram program;
const WebGLProgram programSB;
const WebGLProgram programOBJ;
const WebGLUniformLocation loc_uProjection;
const WebGLUniformLocation loc_uProjectionSB;
const WebGLUniformLocation loc_uProjectionOBJ;
const WebGLUniformLocation loc_uView;
const WebGLUniformLocation loc_uViewSB;
const WebGLUniformLocation loc_uViewOBJ;
const WebGLUniformLocation loc_uModel;
const WebGLUniformLocation loc_uModelSB;
const WebGLUniformLocation loc_uModelOBJ;
const WebGLUniformLocation loc_uLight;
const WebGLUniformLocation loc_uLightOBJ;
const WebGLUniformLocation loc_uNormalMatrix;
const WebGLUniformLocation loc_uInverseViewTransform;
const any frameBuffer;
const float loc_aPosition;
const float loc_aPositionOBJ;
const float loc_aPositionSB;
const float loc_aNormal;
const float loc_aNormalOBJ;
const mat4 model;
const mat4 modelSB;
const any dynamicCubemap;
const lgl.Mesh mesh;
const lgl.Mesh teapot;
const any skyboxCubemap;
const HTMLCanvasElement canvas;
const lgl.Mesh skybox;
const int frameNumber;
const any depthBuffer;

//Declare globals
declare WebGLBuffer mesh.normals;
declare WebGLBuffer mesh.positions;
declare int gl.CULL_FACE;

//Math
declare float Math.PI;
declare float /(float f1, float f2);
declare float -(float f1);
declare int +(int f1, int f2);
declare bool <=(int x, int y);
declare int ++(int x);

//Skybox
declare WebGLBuffer skybox.positions;

//cubeMesh
const lgl.Mesh cubeMesh;
declare WebGLBuffer cubeMesh.normals;
declare WebGLBuffer cubeMesh.positions;

//html
declare float canvas.width;
declare float canvas.height;

//teapot
declare WebGLBuffer teapot.positions;
declare WebGLBuffer teapot.normals;




void renderSkyboxAndCubes(mat4 projection, mat4 view){
    gl.clearColor(0,0,0,1);
    // int comparison = 0;
    // if(gl.COLOR_BUFFER_BIT){ comparison = 1;}
    // if(gl.DEPTH_BUFFER_BIT){ comparison = 1;}
    // gl.clear(comparison);
    #"gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);"; //Lack of bitwise OR

    // Draw the skybox, with its static cubemap texture.
    gl.useProgram(programSB);

    // Set the shader "uniform" parameters.
    gl.uniformMatrix4fv(loc_uProjectionSB, false, projection);
    gl.uniformMatrix4fv(loc_uViewSB, false, view);
    gl.uniformMatrix4fv(loc_uModelSB, false, modelSB);

    // Set the attribute arrays.
    lgl.bind_attrib_buffer(gl, loc_aPositionSB, skybox.positions, 3);

    gl.clearColor(0,0,0,1);
    // gl.clear(comparison);
    #"gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);"; //Lack of bitwise OR

    gl.bindTexture(gl.TEXTURE_CUBE_MAP, skyboxCubemap);

    // Draw the object.
    gl.disable(gl.CULL_FACE);
    lgl.drawMesh(gl, skybox);
    gl.enable(gl.CULL_FACE);

    // Draw the moving cubes, which are drawn with lighting.
    gl.useProgram(programOBJ);

    // Set the attribute arrays.
    lgl.bind_attrib_buffer(gl, loc_aNormal, cubeMesh.normals, 3);
    lgl.bind_attrib_buffer(gl, loc_aPosition, cubeMesh.positions, 3);

    mat4 modelview = mat4.create();
    mat4.multiply(modelview, model, view);

    // Position the light source for the lighting effect.
    vec4 light = vec4.fromValues(0., 30., 0., 0.);

    vec4 transformed = vec4.create();
    vec4.transformMat4(transformed, light, modelview);

    gl.uniform4fv( loc_uLightOBJ, transformed );

    // Set the shader "uniform" parameters.
    gl.uniformMatrix4fv(loc_uProjectionOBJ, false, projection);
    gl.uniformMatrix4fv(loc_uViewOBJ, false, view);

    gl.disableVertexAttribArray(loc_aPositionOBJ);
    gl.disableVertexAttribArray(loc_aNormalOBJ);
}

void createDynamicCubemap() {
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.viewport(0.,0.,512.,512.);  //match size of the texture images
    mat4 projection = mat4.create();
    mat4.perspective(projection, Math.PI/2., 1., 1., 300.);  // Set projection to give 90-degree field of view.

    mat4 view = mat4.create();

    mat4.identity(view);
    mat4.scale(view,view,[-1.,-1.,1.]);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, dynamicCubemap, 0.);
    renderSkyboxAndCubes(projection, view);

    mat4.identity(view);
    mat4.scale(view,view,[-1.,-1.,1.]);
    mat4.rotateY(view,view,Math.PI/2.);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X, dynamicCubemap, 0.);
    renderSkyboxAndCubes(projection, view);

    mat4.identity(view);
    mat4.scale(view,view,[-1.,-1.,1.]);
    mat4.rotateY(view,view,Math.PI);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, dynamicCubemap, 0.);
    renderSkyboxAndCubes(projection, view);

    mat4.identity(view);
    mat4.scale(view,view,[-1.,-1.,1.]);
    mat4.rotateY(view,view,Math.PI/2.);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, dynamicCubemap, 0.);
    renderSkyboxAndCubes(projection, view);

    mat4.identity(view);
    mat4.rotateX(view,view,Math.PI/2.);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, dynamicCubemap, 0.);
    renderSkyboxAndCubes(projection, view);

    mat4.identity(view);
    mat4.rotateX(view,view,Math.PI/2.);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, dynamicCubemap, 0.);
    renderSkyboxAndCubes(projection, view);

    gl.bindTexture(gl.TEXTURE_CUBE_MAP, dynamicCubemap);
    gl.generateMipmap( gl.TEXTURE_CUBE_MAP );
}

void render(mat4 view, mat4 projection){

    createDynamicCubemap();

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);  // draw to screen
    // let canvases = document.getElementsByTagName('canvas');
    // if (canvases.length === 0) {
    //   throw "no canvas found";
    // }
    // let canvas = canvases[0] as HTMLCanvasElement;
    
    #"canvas = document.getElementsByTagName('canvas')[0] as HTMLCanvasElement;"; //Difficulty with the HTMLCollectionOf<HTMLCanvasElement> type
    gl.viewport(0.,0.,canvas.width,canvas.height);

    renderSkyboxAndCubes(projection, view);

    // Use our shader pair.
    gl.useProgram(program);

    // Set the shader "uniform" parameters.
    gl.uniformMatrix4fv(loc_uProjection, false, projection);
    gl.uniformMatrix4fv(loc_uView, false, view);
    gl.uniformMatrix4fv(loc_uModel, false, model);

    mat4 modelView = mat4.create();
    mat3 normalMatrix = mat3.create();
    mat4.multiply(modelView, view, model);
    mat3.normalFromMat4(normalMatrix, modelView);
    gl.uniformMatrix3fv(loc_uNormalMatrix, false, normalMatrix);

    mat3 inverseViewTransform = mat3.create();
    mat3.fromMat4(inverseViewTransform, modelView);
    mat3.invert(inverseViewTransform, inverseViewTransform);
    gl.uniformMatrix3fv(loc_uInverseViewTransform, false, inverseViewTransform);

    // Set the attribute arrays.
    lgl.bind_attrib_buffer(gl, loc_aPosition, teapot.positions, 3);
    lgl.bind_attrib_buffer(gl, loc_aNormal, teapot.normals, 3);

    gl.bindTexture(gl.TEXTURE_CUBE_MAP, dynamicCubemap);

    // Draw the object.
    lgl.drawMesh(gl, teapot);

    frameNumber = frameNumber + 1;
}

void main(){
    frameNumber = 0;

    #"gl = lgl.setup(render_0);";

    // Compile our shaders.
    programSB = lgl.compileProgram(gl,
        require("./vertexSB.lgl"),
        require("./fragmentSB.lgl")
    );

    // Uniform and attribute locations.
    loc_uProjectionSB = lgl.uniformLoc(gl, programSB, "uProjection");
    loc_uViewSB = lgl.uniformLoc(gl, programSB, "uView");
    loc_uModelSB = lgl.uniformLoc(gl, programSB, "uModel");
    loc_aPositionSB = lgl.attribLoc(gl, programSB, "aPosition");

    // We'll draw a cube.
    skybox = lgl.getCube(gl, 300., 300., 300., 1., 1.);

    // Initialize the model position.
    modelSB = mat4.create();

    // Compile our shaders.
    programOBJ = lgl.compileProgram(gl,
        require("./vertexOBJ.lgl"),
        require("./fragmentOBJ.lgl")
    );

    gl.useProgram(programOBJ);

    // Uniform and attribute locations.
    loc_uProjectionOBJ = lgl.uniformLoc(gl, programOBJ, "uProjection");
    loc_uViewOBJ = lgl.uniformLoc(gl, programOBJ, "uView");
    loc_uModelOBJ = lgl.uniformLoc(gl, programOBJ, "uModel");
    loc_uLightOBJ = lgl.uniformLoc(gl, programOBJ, "uLight");
    // let loc_uColorOBJ = lgl.uniformLoc(gl, programOBJ, 'uColor');
    loc_aPositionOBJ = lgl.attribLoc(gl, programOBJ, "aPosition");
    loc_aNormalOBJ = lgl.attribLoc(gl, programOBJ, "aNormal");

    cubeMesh = lgl.getCube(gl, 10., 10., 10., 1., 1.);

    // let movingCubeData: MovingCube[] = [];
    // for (var i = 0; i <= 3; i++) {
    //   movingCubeData.push(new MovingCube(i));
    //   vec3.normalize(movingCubeData[i].localRotationAxis, movingCubeData[i].localRotationAxis);
    //   vec3.normalize(movingCubeData[i].globalRotationAxis, movingCubeData[i].globalRotationAxis);
    //   vec3.normalize(movingCubeData[i].translation, movingCubeData[i].translation);
    //   vec3.scale(movingCubeData[i].translation, movingCubeData[i].translation, 30);
    //   if (Math.random() < 0.5) {
    //     movingCubeData[i].globalAngularVelocity *= -1;
    //   }
    // }

    // Compile our shaders.
    program = lgl.compileProgram(gl,
        require("./vertex.lgl"),
        require("./fragment.lgl")
    );

    // Uniform and attribute locations.
    loc_uProjection = lgl.uniformLoc(gl, program, "uProjection");
    loc_uView = lgl.uniformLoc(gl, program, "uView");
    loc_uModel = lgl.uniformLoc(gl, program, "uModel");
    loc_uNormalMatrix = lgl.uniformLoc(gl, program, "uNormalMatrix");
    loc_uInverseViewTransform = lgl.uniformLoc(gl, program, "uInverseViewTransform");
    loc_aPosition = lgl.attribLoc(gl, program, "aPosition");
    loc_aNormal = lgl.attribLoc(gl, program, "aNormal");

    // We'll draw a teapot.
    teapot = lgl.getBunny(gl);

    // Initialize the model position.
    model = mat4.create();

    mat4.scale(model, model, [4.0, 4., 4.]);

    int ct = 0;
    // const HTMLImageElement[6] asdf;
    #"var img = new Array(6);"; //Difficulty with arrays of custom types
    string[6] urls = [
        require("../resources/park/posx.jpg"), require("../resources/park/negx.jpg"),
        require("../resources/park/posy.jpg"), require("../resources/park/negy.jpg"),
        require("../resources/park/posz.jpg"), require("../resources/park/negz.jpg")
    ];

    float[6] cubemapTargets = [  // targets for use in some gl functions for working with cubemaps
        gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
        gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
        gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
    ];

    dynamicCubemap = gl.createTexture(); // Create the texture object for the reflection map

    gl.bindTexture(gl.TEXTURE_CUBE_MAP, dynamicCubemap);  // create storage for the reflection map images
    for (int i = 0; i <= 5; i = i + 1) {
        gl.texImage2D(cubemapTargets[i], 0., gl.RGBA, 512., 512., 0., gl.RGBA, gl.UNSIGNED_BYTE, null);
        //With null as the last parameter, the previous function allocates memory for the texture and fills it with zeros.
    }

    skyboxCubemap = gl.createTexture();  // Create the texture object for the skybox

    //Problems with: "new" keyword, dot accessor on an indexing lookup, first class functions
    #"for (let i = 0; i <= 5; i++) {";
    #"    img[i] = new Image();";
    #"    img[i].onload = function() {";
    #"    ct++;";
    #"    if (ct == 6) {";
    #"        gl.bindTexture(gl.TEXTURE_CUBE_MAP, skyboxCubemap);";
    #"        var targets = [";
    #"        gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X,";
    #"        gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,";
    #"        gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z";
    #"        ];";
    #"        for (var j = 0; j < 6; j++) {";
    #"        gl.texImage2D(targets[j], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img[j]);";
    #"        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);";
    #"        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);";
    #"        }";
    #"        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);";
    #"    }";
    #"    }";
    #"    img[i].src = urls[i];";
    #"}";

    frameBuffer = gl.createFramebuffer();  // create the framebuffer that will draw to the reflection map
    gl.bindFramebuffer(gl.FRAMEBUFFER,frameBuffer);  // select the framebuffer, so we can attach the depth buffer to it
    depthBuffer = gl.createRenderbuffer();   // renderbuffer for depth buffer in framebuffer
    gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer); // so we can create storage for the depthBuffer
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 512., 512.);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);

}